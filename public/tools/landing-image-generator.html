<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Perception Landing Image Generator</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', system-ui, sans-serif;
      background: #1a1a1a;
      color: #fff;
      min-height: 100vh;
      padding: 40px;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    h1 {
      font-size: 24px;
      font-weight: 600;
      margin-bottom: 8px;
      color: #fff;
    }

    .subtitle {
      color: #888;
      margin-bottom: 32px;
      font-size: 14px;
    }

    .controls {
      display: flex;
      gap: 24px;
      margin-bottom: 32px;
      flex-wrap: wrap;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    label {
      font-size: 12px;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    input[type="text"], select {
      background: #2a2a2a;
      border: 1px solid #444;
      color: #fff;
      padding: 12px 16px;
      border-radius: 8px;
      font-size: 14px;
      min-width: 200px;
    }

    input[type="text"]:focus, select:focus {
      outline: none;
      border-color: #FF6B35;
    }

    .btn {
      background: #FF6B35;
      color: #fff;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn:hover {
      background: #ff7d4d;
      transform: translateY(-1px);
    }

    .btn-secondary {
      background: #333;
      border: 1px solid #444;
    }

    .btn-secondary:hover {
      background: #444;
    }

    .buttons {
      display: flex;
      gap: 12px;
      align-items: flex-end;
    }

    .preview-container {
      background: #111;
      border-radius: 16px;
      padding: 24px;
      display: inline-block;
    }

    #preview {
      border-radius: 12px;
      display: block;
    }

    .dimensions {
      margin-top: 16px;
      font-size: 12px;
      color: #666;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Landing Image Generator</h1>
    <p class="subtitle">Generate hero images in the Perception style</p>

    <div class="controls">
      <div class="control-group">
        <label>Title Line 1</label>
        <input type="text" id="title1" value="The Intelligence Layer" placeholder="First line...">
      </div>

      <div class="control-group">
        <label>Title Line 2</label>
        <input type="text" id="title2" value="for New Finance" placeholder="Second line (optional)">
      </div>

      <div class="control-group">
        <label>Pattern Style</label>
        <select id="pattern">
          <option value="waves">Braille Waves</option>
          <option value="diagonal">Slash Petals</option>
          <option value="blocks">Block Density</option>
          <option value="water">Water Flow</option>
          <option value="noise">Perlin Noise</option>
          <option value="grid">Grid Distortion</option>
        </select>
      </div>

      <div class="control-group">
        <label>Dimensions</label>
        <select id="dimensions">
          <option value="1200x630">Open Graph (1200×630)</option>
          <option value="1920x1080">Full HD (1920×1080)</option>
          <option value="1080x1080">Square (1080×1080)</option>
          <option value="1200x600">Twitter Card (1200×600)</option>
          <option value="800x600">Hero Card (800×600)</option>
        </select>
      </div>

      <div class="buttons">
        <button class="btn btn-secondary" onclick="regenerate()">Regenerate Pattern</button>
        <button class="btn" onclick="download()">Download PNG</button>
      </div>
    </div>

    <div class="preview-container">
      <canvas id="preview" width="1200" height="630"></canvas>
      <div class="dimensions" id="dimLabel">1200 × 630 px</div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('preview');
    const ctx = canvas.getContext('2d');

    // Character sets for different patterns (matching site ASCII art)
    const CHARS = {
      braille: '⠁⠂⠄⠈⠐⠠⡀⢀⠃⠅⠘⠨⠊⠋⠌⠍⠎⠏',
      diagonal: '/\\|',
      blocks: '░▒▓█',
      water: '~≈≋⋿⊰⊱◟◝',
      lines: '─│┌┐└┘├┤┬┴┼'
    };

    // Pattern state
    let patternState = {};

    // Load logo image
    const logoImg = new Image();
    logoImg.src = '/brand/logo-light.png';

    // Initialize pattern state
    function initPattern() {
      const pattern = document.getElementById('pattern').value;
      patternState = { pattern };

      switch (pattern) {
        case 'waves':
          patternState.waves = [];
          for (let i = 0; i < 4; i++) {
            patternState.waves.push({
              x: 0.2 + Math.random() * 0.6,
              y: 0.2 + Math.random() * 0.6,
              frequency: 0.15 + Math.random() * 0.2,
              amplitude: 0.6 + Math.random() * 0.4,
              phase: Math.random() * Math.PI * 2
            });
          }
          break;

        case 'diagonal':
          // Slash Petals - based on AsciiDiagonalPetals.tsx
          patternState.wave1 = { freq: 0.08 + Math.random() * 0.04, phase: Math.random() * Math.PI * 2 };
          patternState.wave2 = { freq: 0.06 + Math.random() * 0.04, phase: Math.random() * Math.PI * 2 };
          patternState.time = Math.random() * 10;
          break;

        case 'blocks':
          // Block Density - based on AsciiBlob.tsx
          patternState.density = 30 + Math.random() * 20;
          patternState.phase = Math.random() * Math.PI * 2;
          patternState.seed = Math.random() * 1000;
          break;

        case 'water':
          // Water Flow - based on WaterAscii.tsx
          patternState.frame = Math.random() * 100;
          patternState.centerX = 0.4 + Math.random() * 0.2;
          patternState.centerY = 0.4 + Math.random() * 0.2;
          break;

        case 'noise':
          patternState.seed = Math.random() * 1000;
          patternState.scale = 0.02 + Math.random() * 0.03;
          patternState.octaves = 3 + Math.floor(Math.random() * 2);
          break;

        case 'grid':
          patternState.distortX = Math.random() * Math.PI * 2;
          patternState.distortY = Math.random() * Math.PI * 2;
          patternState.amplitude = 0.3 + Math.random() * 0.4;
          break;
      }
    }

    // Simple noise function
    function noise(x, y, seed) {
      const n = Math.sin(x * 12.9898 + y * 78.233 + seed) * 43758.5453;
      return n - Math.floor(n);
    }

    // Smooth noise
    function smoothNoise(x, y, seed) {
      const x0 = Math.floor(x), y0 = Math.floor(y);
      const fx = x - x0, fy = y - y0;
      const sx = fx * fx * (3 - 2 * fx), sy = fy * fy * (3 - 2 * fy);

      const n00 = noise(x0, y0, seed);
      const n10 = noise(x0 + 1, y0, seed);
      const n01 = noise(x0, y0 + 1, seed);
      const n11 = noise(x0 + 1, y0 + 1, seed);

      return n00 * (1 - sx) * (1 - sy) + n10 * sx * (1 - sy) + n01 * (1 - sx) * sy + n11 * sx * sy;
    }

    // Generate pattern based on type
    function generatePattern(width, height) {
      const pattern = document.getElementById('pattern').value;
      const cellSize = 14;
      const gridWidth = Math.floor(width / cellSize);
      const gridHeight = Math.floor(height / cellSize);

      ctx.font = '14px monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      switch (pattern) {
        case 'waves':
          generateWaves(gridWidth, gridHeight, cellSize);
          break;
        case 'diagonal':
          generateDiagonal(gridWidth, gridHeight, cellSize);
          break;
        case 'blocks':
          generateBlocks(gridWidth, gridHeight, cellSize);
          break;
        case 'water':
          generateWater(gridWidth, gridHeight, cellSize);
          break;
        case 'noise':
          generateNoise(gridWidth, gridHeight, cellSize);
          break;
        case 'grid':
          generateGrid(gridWidth, gridHeight, cellSize);
          break;
      }
    }

    function generateWaves(gridWidth, gridHeight, cellSize) {
      const chars = CHARS.braille;
      for (let y = 0; y < gridHeight; y++) {
        for (let x = 0; x < gridWidth; x++) {
          const normX = x / gridWidth;
          const normY = y / gridHeight;
          let totalWave = 0;

          patternState.waves.forEach(wave => {
            const dx = normX - wave.x;
            const dy = normY - wave.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const falloff = 1 / (1 + dist * 3);
            const value = Math.sin(dist * wave.frequency * 50 + wave.phase) * wave.amplitude * falloff;
            totalWave += value;
          });

          const normalizedWave = (totalWave + 2) / 4;
          if (Math.abs(totalWave) > 0.15) {
            const charIndex = Math.min(chars.length - 1, Math.max(0, Math.floor(normalizedWave * (chars.length - 1))));
            const opacity = Math.min(0.85, Math.max(0.25, 0.25 + (normalizedWave * 0.6)));
            ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.fillText(chars[charIndex], x * cellSize + cellSize / 2, y * cellSize + cellSize / 2);
          }
        }
      }
    }

    // Slash Petals - based on AsciiDiagonalPetals.tsx
    function generateDiagonal(gridWidth, gridHeight, cellSize) {
      const chars = CHARS.diagonal;
      const time = patternState.time;

      for (let y = 0; y < gridHeight; y++) {
        for (let x = 0; x < gridWidth; x++) {
          // Two forces in harmony - from the site component
          const wave1 = Math.sin((x + y) / 4 + time);
          const wave2 = Math.cos((x - y) / 4 - time * 0.7);

          // Boundary calculation for fade effect
          const boundaryX = Math.abs(x - gridWidth / 2) / (gridWidth / 2);
          const boundaryY = Math.abs(y - gridHeight / 2) / (gridHeight / 2);
          const boundary = Math.max(boundaryX, boundaryY);

          if (boundary < 0.85) {
            const combined = wave1 * 0.6 + wave2 * 0.4;
            const fade = 1 - (boundary / 0.85);
            const value = combined * fade;

            // Character selection based on value thresholds
            let char = ' ';
            if (value > 0.3) char = chars[0];      // /
            else if (value < -0.3) char = chars[1]; // \
            else if (Math.abs(value) < 0.1) char = chars[2]; // |

            if (char !== ' ') {
              const opacity = 0.3 + Math.abs(value) * 0.5;
              ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
              ctx.fillText(char, x * cellSize + cellSize / 2, y * cellSize + cellSize / 2);
            }
          }
        }
      }
    }

    // Block Density - based on AsciiBlob.tsx
    function generateBlocks(gridWidth, gridHeight, cellSize) {
      const chars = CHARS.blocks;
      const density = patternState.density;
      const phase = patternState.phase;
      const seed = patternState.seed;

      const centerX = gridWidth / 2;
      const centerY = gridHeight / 2;

      for (let y = 0; y < gridHeight; y++) {
        for (let x = 0; x < gridWidth; x++) {
          // Distance from center (normalized)
          const dx = (x - centerX) / centerX;
          const dy = (y - centerY) / centerY;
          const distFromCenter = Math.sqrt(dx * dx + dy * dy);

          // Pattern calculation similar to AsciiBlob
          let noiseValue = Math.sin(distFromCenter * 3 + phase);
          noiseValue += Math.cos(x * 0.1 - y * 0.1 + phase * 0.4) * 0.3;
          noiseValue = (noiseValue + 1) / 2; // Normalize to 0-1

          // Apply density adjustment
          noiseValue = noiseValue * (density / 100);

          // Add some noise variation
          const n = noise(x * 0.15, y * 0.15, seed);
          noiseValue = noiseValue * 0.7 + n * 0.3;

          if (noiseValue > 0.15) {
            const charIndex = Math.floor(noiseValue * chars.length);
            const char = chars[Math.min(Math.max(0, charIndex), chars.length - 1)];
            const opacity = 0.25 + noiseValue * 0.6;
            ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.fillText(char, x * cellSize + cellSize / 2, y * cellSize + cellSize / 2);
          }
        }
      }
    }

    // Water Flow - based on WaterAscii.tsx
    function generateWater(gridWidth, gridHeight, cellSize) {
      const chars = CHARS.water;
      const frame = patternState.frame;
      const centerX = patternState.centerX;
      const centerY = patternState.centerY;

      for (let y = 0; y < gridHeight; y++) {
        for (let x = 0; x < gridWidth; x++) {
          const normX = x / gridWidth;
          const normY = y / gridHeight;

          // Distance from center
          const dx = normX - centerX;
          const dy = normY - centerY;
          const dist = Math.sqrt(dx * dx + dy * dy);

          // Wave pattern - similar to WaterAscii
          const wave = Math.sin(x / 3 + y / 5 + frame / 4 + dist * 10) +
                      Math.cos(x / 4 - y / 3 - frame / 5) +
                      Math.sin(frame / 8 + normX * Math.PI * 2);

          // Character selection based on wave value
          const charValue = (wave + 2) * (chars.length / 4) + dist * 5;
          const charIndex = Math.floor(Math.abs(charValue)) % chars.length;

          // Opacity based on distance and wave
          const opacity = Math.max(0.2, Math.min(0.75, 1 - dist + Math.sin(wave) / 3));

          ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
          ctx.fillText(chars[charIndex], x * cellSize + cellSize / 2, y * cellSize + cellSize / 2);
        }
      }
    }

    function generateNoise(gridWidth, gridHeight, cellSize) {
      const chars = CHARS.blocks;

      for (let y = 0; y < gridHeight; y++) {
        for (let x = 0; x < gridWidth; x++) {
          let value = 0;
          let amplitude = 1;
          let frequency = patternState.scale;

          for (let o = 0; o < patternState.octaves; o++) {
            value += smoothNoise(x * frequency, y * frequency, patternState.seed) * amplitude;
            amplitude *= 0.5;
            frequency *= 2;
          }

          value = value / 2;

          if (value > 0.25 && value < 0.75) {
            const charIndex = Math.floor(value * (chars.length - 1));
            const opacity = 0.3 + value * 0.5;
            ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.fillText(chars[charIndex], x * cellSize + cellSize / 2, y * cellSize + cellSize / 2);
          }
        }
      }
    }

    function generateGrid(gridWidth, gridHeight, cellSize) {
      const chars = CHARS.lines;

      for (let y = 0; y < gridHeight; y++) {
        for (let x = 0; x < gridWidth; x++) {
          const distortX = Math.sin(y * 0.1 + patternState.distortX) * patternState.amplitude;
          const distortY = Math.cos(x * 0.1 + patternState.distortY) * patternState.amplitude;

          const isHorizontal = y % 3 === 0;
          const isVertical = x % 4 === 0;
          const isIntersection = isHorizontal && isVertical;

          if (isIntersection || isHorizontal || isVertical) {
            let charIndex;
            if (isIntersection) charIndex = 10; // ┼
            else if (isHorizontal) charIndex = 0; // ─
            else charIndex = 1; // │

            const waveInfluence = Math.abs(distortX + distortY);
            const opacity = 0.2 + waveInfluence * 0.4;

            const offsetX = distortX * cellSize * 0.3;
            const offsetY = distortY * cellSize * 0.3;

            ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.fillText(chars[charIndex], x * cellSize + cellSize / 2 + offsetX, y * cellSize + cellSize / 2 + offsetY);
          }
        }
      }
    }

    function generateImage() {
      const width = canvas.width;
      const height = canvas.height;

      // Black background
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, width, height);

      // Generate pattern
      generatePattern(width, height);

      // Draw title text
      const title1 = document.getElementById('title1').value;
      const title2 = document.getElementById('title2').value;

      const baseFontSize = Math.min(width * 0.065, 80);

      ctx.fillStyle = '#ffffff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = `500 ${baseFontSize}px Inter, system-ui, sans-serif`;

      const centerX = width / 2;
      const centerY = height / 2;

      if (title2) {
        const lineHeight = baseFontSize * 1.15;
        ctx.fillText(title1, centerX, centerY - lineHeight / 2);
        ctx.fillText(title2, centerX, centerY + lineHeight / 2);
      } else {
        ctx.fillText(title1, centerX, centerY);
      }

      // Draw logo and brand name in bottom right
      const padding = width * 0.03;
      const logoHeight = height * 0.06;
      const logoColor = '#F5F3ED';

      if (logoImg.complete && logoImg.naturalWidth > 0) {
        // Calculate logo dimensions maintaining aspect ratio
        const logoWidth = (logoImg.naturalWidth / logoImg.naturalHeight) * logoHeight;

        // Calculate text width
        ctx.font = `500 ${logoHeight * 0.5}px Inter, system-ui, sans-serif`;
        const textWidth = ctx.measureText('Perception').width;
        const gap = logoHeight * 0.3;
        const totalWidth = logoWidth + gap + textWidth;

        // Position from right edge
        const startX = width - padding - totalWidth;
        const logoY = height - padding - logoHeight;

        // Draw the logo image
        ctx.drawImage(logoImg, startX, logoY, logoWidth, logoHeight);

        // Draw "Perception" text
        ctx.fillStyle = logoColor;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        ctx.font = `500 ${logoHeight * 0.5}px Inter, system-ui, sans-serif`;
        ctx.fillText('Perception', startX + logoWidth + gap, logoY + logoHeight / 2);
      }
    }

    function regenerate() {
      initPattern();
      generateImage();
    }

    function download() {
      const link = document.createElement('a');
      const title1 = document.getElementById('title1').value || 'landing';
      const filename = title1.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/-+$/, '');
      link.download = `${filename}-${canvas.width}x${canvas.height}.png`;
      link.href = canvas.toDataURL('image/png');
      link.click();
    }

    // Update dimensions
    document.getElementById('dimensions').addEventListener('change', function() {
      const [w, h] = this.value.split('x').map(Number);
      canvas.width = w;
      canvas.height = h;
      document.getElementById('dimLabel').textContent = `${w} × ${h} px`;
      generateImage();
    });

    // Update pattern
    document.getElementById('pattern').addEventListener('change', function() {
      initPattern();
      generateImage();
    });

    // Regenerate on title change
    document.getElementById('title1').addEventListener('input', generateImage);
    document.getElementById('title2').addEventListener('input', generateImage);

    // Initialize
    initPattern();

    // Regenerate when logo loads
    logoImg.onload = function() {
      generateImage();
    };

    // Generate after fonts are loaded
    if (document.fonts) {
      document.fonts.ready.then(() => {
        generateImage();
      });
    } else {
      setTimeout(generateImage, 100);
    }
  </script>
</body>
</html>
