<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Perception Landing Image Generator</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', system-ui, sans-serif;
      background: #1a1a1a;
      color: #fff;
      min-height: 100vh;
      padding: 40px;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    h1 {
      font-size: 24px;
      font-weight: 600;
      margin-bottom: 8px;
      color: #fff;
    }

    .subtitle {
      color: #888;
      margin-bottom: 32px;
      font-size: 14px;
    }

    .controls {
      display: flex;
      gap: 24px;
      margin-bottom: 32px;
      flex-wrap: wrap;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    label {
      font-size: 12px;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    input[type="text"], select {
      background: #2a2a2a;
      border: 1px solid #444;
      color: #fff;
      padding: 12px 16px;
      border-radius: 8px;
      font-size: 14px;
      min-width: 200px;
    }

    input[type="text"]:focus, select:focus {
      outline: none;
      border-color: #FF6B35;
    }

    .btn {
      background: #FF6B35;
      color: #fff;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn:hover {
      background: #ff7d4d;
      transform: translateY(-1px);
    }

    .btn-secondary {
      background: #333;
      border: 1px solid #444;
    }

    .btn-secondary:hover {
      background: #444;
    }

    .buttons {
      display: flex;
      gap: 12px;
      align-items: flex-end;
    }

    .preview-container {
      background: #111;
      border-radius: 16px;
      padding: 24px;
      display: inline-block;
    }

    #preview {
      border-radius: 12px;
      display: block;
    }

    .dimensions {
      margin-top: 16px;
      font-size: 12px;
      color: #666;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Landing Image Generator</h1>
    <p class="subtitle">Generate hero images in the Perception style</p>

    <div class="controls">
      <div class="control-group">
        <label>Title Line 1</label>
        <input type="text" id="title1" value="The Intelligence Layer" placeholder="First line...">
      </div>

      <div class="control-group">
        <label>Title Line 2</label>
        <input type="text" id="title2" value="for New Finance" placeholder="Second line (optional)">
      </div>

      <div class="control-group">
        <label>Pattern Style</label>
        <select id="pattern">
          <option value="waves">Waves (Braille dots)</option>
          <option value="binary">Binary Flow</option>
          <option value="diagonal">Diagonal Petals</option>
          <option value="constellation">Constellation</option>
          <option value="matrix">Matrix Rain</option>
          <option value="ripple">Ripple Circles</option>
          <option value="noise">Perlin Noise</option>
          <option value="grid">Grid Distortion</option>
        </select>
      </div>

      <div class="control-group">
        <label>Dimensions</label>
        <select id="dimensions">
          <option value="1200x630">Open Graph (1200×630)</option>
          <option value="1920x1080">Full HD (1920×1080)</option>
          <option value="1080x1080">Square (1080×1080)</option>
          <option value="1200x600">Twitter Card (1200×600)</option>
          <option value="800x600">Hero Card (800×600)</option>
        </select>
      </div>

      <div class="buttons">
        <button class="btn btn-secondary" onclick="regenerate()">Regenerate Pattern</button>
        <button class="btn" onclick="download()">Download PNG</button>
      </div>
    </div>

    <div class="preview-container">
      <canvas id="preview" width="1200" height="630"></canvas>
      <div class="dimensions" id="dimLabel">1200 × 630 px</div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('preview');
    const ctx = canvas.getContext('2d');

    // Character sets for different patterns
    const CHARS = {
      braille: '⠁⠂⠄⠈⠐⠠⡀⢀⠃⠅⠘⠨⠊⠋⠌⠍⠎⠏',
      binary: '01~',
      diagonal: '/\\|─',
      dots: '·∘○◦●◯',
      blocks: '░▒▓█',
      stars: '✦✧★☆·',
      matrix: 'ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐﾑﾒﾓﾔﾕﾖﾗﾘﾙﾚﾛﾜﾝ01234',
      lines: '─│┌┐└┘├┤┬┴┼'
    };

    // Pattern state
    let patternState = {};

    // Load logo image
    const logoImg = new Image();
    logoImg.src = '/brand/logo-light.png';

    // Initialize pattern state
    function initPattern() {
      const pattern = document.getElementById('pattern').value;
      patternState = { pattern };

      switch (pattern) {
        case 'waves':
          patternState.waves = [];
          for (let i = 0; i < 4; i++) {
            patternState.waves.push({
              x: 0.2 + Math.random() * 0.6,
              y: 0.2 + Math.random() * 0.6,
              frequency: 0.15 + Math.random() * 0.2,
              amplitude: 0.6 + Math.random() * 0.4,
              phase: Math.random() * Math.PI * 2
            });
          }
          break;

        case 'binary':
          patternState.flowLines = [];
          for (let i = 0; i < 8; i++) {
            patternState.flowLines.push({
              y: Math.random(),
              speed: 0.3 + Math.random() * 0.7,
              offset: Math.random() * 100
            });
          }
          patternState.seed = Math.random() * 1000;
          break;

        case 'diagonal':
          patternState.wave1 = { freq: 0.05 + Math.random() * 0.05, phase: Math.random() * Math.PI * 2 };
          patternState.wave2 = { freq: 0.03 + Math.random() * 0.04, phase: Math.random() * Math.PI * 2 };
          break;

        case 'constellation':
          patternState.stars = [];
          const numStars = 80 + Math.floor(Math.random() * 60);
          for (let i = 0; i < numStars; i++) {
            patternState.stars.push({
              x: Math.random(),
              y: Math.random(),
              size: 0.3 + Math.random() * 0.7,
              brightness: 0.3 + Math.random() * 0.7
            });
          }
          patternState.connections = [];
          patternState.stars.forEach((star, i) => {
            patternState.stars.forEach((other, j) => {
              if (i < j) {
                const dist = Math.sqrt(Math.pow(star.x - other.x, 2) + Math.pow(star.y - other.y, 2));
                if (dist < 0.15 && Math.random() > 0.5) {
                  patternState.connections.push([i, j, dist]);
                }
              }
            });
          });
          break;

        case 'matrix':
          patternState.columns = [];
          const numCols = 60 + Math.floor(Math.random() * 40);
          for (let i = 0; i < numCols; i++) {
            patternState.columns.push({
              x: Math.random(),
              length: 5 + Math.floor(Math.random() * 15),
              offset: Math.random() * 100,
              speed: 0.5 + Math.random() * 1.5
            });
          }
          break;

        case 'ripple':
          patternState.centers = [];
          const numCenters = 2 + Math.floor(Math.random() * 3);
          for (let i = 0; i < numCenters; i++) {
            patternState.centers.push({
              x: 0.2 + Math.random() * 0.6,
              y: 0.2 + Math.random() * 0.6,
              phase: Math.random() * Math.PI * 2
            });
          }
          break;

        case 'noise':
          patternState.seed = Math.random() * 1000;
          patternState.scale = 0.02 + Math.random() * 0.03;
          patternState.octaves = 3 + Math.floor(Math.random() * 2);
          break;

        case 'grid':
          patternState.distortX = Math.random() * Math.PI * 2;
          patternState.distortY = Math.random() * Math.PI * 2;
          patternState.amplitude = 0.3 + Math.random() * 0.4;
          break;
      }
    }

    // Simple noise function
    function noise(x, y, seed) {
      const n = Math.sin(x * 12.9898 + y * 78.233 + seed) * 43758.5453;
      return n - Math.floor(n);
    }

    // Smooth noise
    function smoothNoise(x, y, seed) {
      const x0 = Math.floor(x), y0 = Math.floor(y);
      const fx = x - x0, fy = y - y0;
      const sx = fx * fx * (3 - 2 * fx), sy = fy * fy * (3 - 2 * fy);

      const n00 = noise(x0, y0, seed);
      const n10 = noise(x0 + 1, y0, seed);
      const n01 = noise(x0, y0 + 1, seed);
      const n11 = noise(x0 + 1, y0 + 1, seed);

      return n00 * (1 - sx) * (1 - sy) + n10 * sx * (1 - sy) + n01 * (1 - sx) * sy + n11 * sx * sy;
    }

    // Generate pattern based on type
    function generatePattern(width, height) {
      const pattern = document.getElementById('pattern').value;
      const cellSize = 14;
      const gridWidth = Math.floor(width / cellSize);
      const gridHeight = Math.floor(height / cellSize);

      ctx.font = '14px monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      switch (pattern) {
        case 'waves':
          generateWaves(gridWidth, gridHeight, cellSize);
          break;
        case 'binary':
          generateBinary(gridWidth, gridHeight, cellSize);
          break;
        case 'diagonal':
          generateDiagonal(gridWidth, gridHeight, cellSize);
          break;
        case 'constellation':
          generateConstellation(width, height);
          break;
        case 'matrix':
          generateMatrix(gridWidth, gridHeight, cellSize);
          break;
        case 'ripple':
          generateRipple(gridWidth, gridHeight, cellSize);
          break;
        case 'noise':
          generateNoise(gridWidth, gridHeight, cellSize);
          break;
        case 'grid':
          generateGrid(gridWidth, gridHeight, cellSize);
          break;
      }
    }

    function generateWaves(gridWidth, gridHeight, cellSize) {
      const chars = CHARS.braille;
      for (let y = 0; y < gridHeight; y++) {
        for (let x = 0; x < gridWidth; x++) {
          const normX = x / gridWidth;
          const normY = y / gridHeight;
          let totalWave = 0;

          patternState.waves.forEach(wave => {
            const dx = normX - wave.x;
            const dy = normY - wave.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const falloff = 1 / (1 + dist * 3);
            const value = Math.sin(dist * wave.frequency * 50 + wave.phase) * wave.amplitude * falloff;
            totalWave += value;
          });

          const normalizedWave = (totalWave + 2) / 4;
          if (Math.abs(totalWave) > 0.15) {
            const charIndex = Math.min(chars.length - 1, Math.max(0, Math.floor(normalizedWave * (chars.length - 1))));
            const opacity = Math.min(0.85, Math.max(0.25, 0.25 + (normalizedWave * 0.6)));
            ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.fillText(chars[charIndex], x * cellSize + cellSize / 2, y * cellSize + cellSize / 2);
          }
        }
      }
    }

    function generateBinary(gridWidth, gridHeight, cellSize) {
      const chars = CHARS.binary;
      for (let y = 0; y < gridHeight; y++) {
        for (let x = 0; x < gridWidth; x++) {
          const normX = x / gridWidth;
          const normY = y / gridHeight;

          let inFlow = false;
          let flowIntensity = 0;

          patternState.flowLines.forEach(line => {
            const dist = Math.abs(normY - line.y);
            if (dist < 0.08) {
              inFlow = true;
              flowIntensity = Math.max(flowIntensity, 1 - dist / 0.08);
            }
          });

          const n = noise(x * 0.1, y * 0.1, patternState.seed);

          if (inFlow || n > 0.6) {
            const charIndex = Math.floor(n * chars.length) % chars.length;
            const opacity = inFlow ? 0.4 + flowIntensity * 0.5 : 0.2 + n * 0.3;
            ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.fillText(chars[charIndex], x * cellSize + cellSize / 2, y * cellSize + cellSize / 2);
          }
        }
      }
    }

    function generateDiagonal(gridWidth, gridHeight, cellSize) {
      const chars = CHARS.diagonal;
      for (let y = 0; y < gridHeight; y++) {
        for (let x = 0; x < gridWidth; x++) {
          const wave1 = Math.sin(x * patternState.wave1.freq + patternState.wave1.phase);
          const wave2 = Math.sin(y * patternState.wave2.freq + patternState.wave2.phase);
          const combined = wave1 * 0.6 + wave2 * 0.4;

          const centerX = gridWidth / 2, centerY = gridHeight / 2;
          const dist = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
          const maxDist = Math.sqrt(centerX * centerX + centerY * centerY);
          const fade = 1 - (dist / maxDist) * 0.5;

          if (Math.abs(combined) > 0.2) {
            const charIndex = Math.floor((combined + 1) / 2 * chars.length) % chars.length;
            const opacity = (0.3 + Math.abs(combined) * 0.5) * fade;
            ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.fillText(chars[charIndex], x * cellSize + cellSize / 2, y * cellSize + cellSize / 2);
          }
        }
      }
    }

    function generateConstellation(width, height) {
      // Draw connections
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
      ctx.lineWidth = 1;
      patternState.connections.forEach(([i, j, dist]) => {
        const s1 = patternState.stars[i];
        const s2 = patternState.stars[j];
        ctx.beginPath();
        ctx.moveTo(s1.x * width, s1.y * height);
        ctx.lineTo(s2.x * width, s2.y * height);
        ctx.stroke();
      });

      // Draw stars
      const chars = CHARS.stars;
      ctx.font = '16px monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      patternState.stars.forEach(star => {
        const charIndex = Math.floor(star.size * (chars.length - 1));
        const opacity = 0.3 + star.brightness * 0.6;
        ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
        ctx.fillText(chars[charIndex], star.x * width, star.y * height);
      });
    }

    function generateMatrix(gridWidth, gridHeight, cellSize) {
      const chars = CHARS.matrix;

      patternState.columns.forEach(col => {
        const colX = Math.floor(col.x * gridWidth);
        const startY = Math.floor(col.offset) % gridHeight;

        for (let i = 0; i < col.length; i++) {
          const y = (startY + i) % gridHeight;
          const charIndex = Math.floor(noise(colX, y, col.offset) * chars.length);
          const fadePos = i / col.length;
          const opacity = 0.2 + (1 - fadePos) * 0.7;

          ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
          ctx.fillText(chars[charIndex], colX * cellSize + cellSize / 2, y * cellSize + cellSize / 2);
        }
      });
    }

    function generateRipple(gridWidth, gridHeight, cellSize) {
      const chars = CHARS.dots;

      for (let y = 0; y < gridHeight; y++) {
        for (let x = 0; x < gridWidth; x++) {
          const normX = x / gridWidth;
          const normY = y / gridHeight;

          let totalRipple = 0;
          patternState.centers.forEach(center => {
            const dist = Math.sqrt(Math.pow(normX - center.x, 2) + Math.pow(normY - center.y, 2));
            const ripple = Math.sin(dist * 30 + center.phase) * Math.exp(-dist * 2);
            totalRipple += ripple;
          });

          const normalized = (totalRipple + 1) / 2;
          if (Math.abs(totalRipple) > 0.1) {
            const charIndex = Math.floor(normalized * (chars.length - 1));
            const opacity = 0.2 + Math.abs(totalRipple) * 0.6;
            ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.fillText(chars[charIndex], x * cellSize + cellSize / 2, y * cellSize + cellSize / 2);
          }
        }
      }
    }

    function generateNoise(gridWidth, gridHeight, cellSize) {
      const chars = CHARS.blocks;

      for (let y = 0; y < gridHeight; y++) {
        for (let x = 0; x < gridWidth; x++) {
          let value = 0;
          let amplitude = 1;
          let frequency = patternState.scale;

          for (let o = 0; o < patternState.octaves; o++) {
            value += smoothNoise(x * frequency, y * frequency, patternState.seed) * amplitude;
            amplitude *= 0.5;
            frequency *= 2;
          }

          value = value / 2;

          if (value > 0.25 && value < 0.75) {
            const charIndex = Math.floor(value * (chars.length - 1));
            const opacity = 0.3 + value * 0.5;
            ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.fillText(chars[charIndex], x * cellSize + cellSize / 2, y * cellSize + cellSize / 2);
          }
        }
      }
    }

    function generateGrid(gridWidth, gridHeight, cellSize) {
      const chars = CHARS.lines;

      for (let y = 0; y < gridHeight; y++) {
        for (let x = 0; x < gridWidth; x++) {
          const distortX = Math.sin(y * 0.1 + patternState.distortX) * patternState.amplitude;
          const distortY = Math.cos(x * 0.1 + patternState.distortY) * patternState.amplitude;

          const isHorizontal = y % 3 === 0;
          const isVertical = x % 4 === 0;
          const isIntersection = isHorizontal && isVertical;

          if (isIntersection || isHorizontal || isVertical) {
            let charIndex;
            if (isIntersection) charIndex = 10; // ┼
            else if (isHorizontal) charIndex = 0; // ─
            else charIndex = 1; // │

            const waveInfluence = Math.abs(distortX + distortY);
            const opacity = 0.2 + waveInfluence * 0.4;

            const offsetX = distortX * cellSize * 0.3;
            const offsetY = distortY * cellSize * 0.3;

            ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.fillText(chars[charIndex], x * cellSize + cellSize / 2 + offsetX, y * cellSize + cellSize / 2 + offsetY);
          }
        }
      }
    }

    function generateImage() {
      const width = canvas.width;
      const height = canvas.height;

      // Black background
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, width, height);

      // Generate pattern
      generatePattern(width, height);

      // Draw title text
      const title1 = document.getElementById('title1').value;
      const title2 = document.getElementById('title2').value;

      const baseFontSize = Math.min(width * 0.065, 80);

      ctx.fillStyle = '#ffffff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = `500 ${baseFontSize}px Inter, system-ui, sans-serif`;

      const centerX = width / 2;
      const centerY = height / 2;

      if (title2) {
        const lineHeight = baseFontSize * 1.15;
        ctx.fillText(title1, centerX, centerY - lineHeight / 2);
        ctx.fillText(title2, centerX, centerY + lineHeight / 2);
      } else {
        ctx.fillText(title1, centerX, centerY);
      }

      // Draw logo and brand name in bottom right
      const padding = width * 0.03;
      const logoHeight = height * 0.06;
      const logoColor = '#F5F3ED';

      if (logoImg.complete && logoImg.naturalWidth > 0) {
        // Calculate logo dimensions maintaining aspect ratio
        const logoWidth = (logoImg.naturalWidth / logoImg.naturalHeight) * logoHeight;

        // Calculate text width
        ctx.font = `500 ${logoHeight * 0.5}px Inter, system-ui, sans-serif`;
        const textWidth = ctx.measureText('Perception').width;
        const gap = logoHeight * 0.3;
        const totalWidth = logoWidth + gap + textWidth;

        // Position from right edge
        const startX = width - padding - totalWidth;
        const logoY = height - padding - logoHeight;

        // Draw the logo image
        ctx.drawImage(logoImg, startX, logoY, logoWidth, logoHeight);

        // Draw "Perception" text
        ctx.fillStyle = logoColor;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        ctx.font = `500 ${logoHeight * 0.5}px Inter, system-ui, sans-serif`;
        ctx.fillText('Perception', startX + logoWidth + gap, logoY + logoHeight / 2);
      }
    }

    function regenerate() {
      initPattern();
      generateImage();
    }

    function download() {
      const link = document.createElement('a');
      const title1 = document.getElementById('title1').value || 'landing';
      const filename = title1.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/-+$/, '');
      link.download = `${filename}-${canvas.width}x${canvas.height}.png`;
      link.href = canvas.toDataURL('image/png');
      link.click();
    }

    // Update dimensions
    document.getElementById('dimensions').addEventListener('change', function() {
      const [w, h] = this.value.split('x').map(Number);
      canvas.width = w;
      canvas.height = h;
      document.getElementById('dimLabel').textContent = `${w} × ${h} px`;
      generateImage();
    });

    // Update pattern
    document.getElementById('pattern').addEventListener('change', function() {
      initPattern();
      generateImage();
    });

    // Regenerate on title change
    document.getElementById('title1').addEventListener('input', generateImage);
    document.getElementById('title2').addEventListener('input', generateImage);

    // Initialize
    initPattern();

    // Regenerate when logo loads
    logoImg.onload = function() {
      generateImage();
    };

    // Generate after fonts are loaded
    if (document.fonts) {
      document.fonts.ready.then(() => {
        generateImage();
      });
    } else {
      setTimeout(generateImage, 100);
    }
  </script>
</body>
</html>
